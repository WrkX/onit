<!DOCTYPE html>
<html style="background: transparent;">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/latex.js/dist/latex.min.js"></script>
    <style>
        :root {
            --base-font-size: %fpx;
        }
        html, body {
            margin: 0;
            padding: 0;
            background: transparent !important;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.5;
            font-size: var(--base-font-size);
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .latex-block {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            margin: 5px 0;
            padding: 12px;
            overflow: hidden;
            background: rgba(30, 30, 30, 0.6) !important;
        }
        .latex-title {
            background: rgba(60, 60, 60, 0.6) !important;
            padding: 8px 12px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .latex-content {
            overflow-x: auto;
            color: white;
        }
        #formula {
            background: transparent !important;
            color: white;
            width: 100%;
            min-height: 100%;
            overflow: visible;
        }
        .MathJax { color: white !important; }
        .MathJax * { color: white !important; }
        mjx-container { color: white !important; }
        mjx-container * { color: white !important; }
        
        /* Styles for LaTeX.js */
        .latex-js-output {
            color: white !important;
            background: transparent !important;
        }
        .latex-js-output * {
            color: white !important;
            background: transparent !important;
        }
        .latex-js-output .section {
            margin: 1em 0;
        }
        .latex-js-output .enumerate {
            padding-left: 2em;
        }
        .latex-js-output .itemize {
            padding-left: 2em;
        }
        .latex-js-output table {
            border-collapse: collapse;
            margin: 1em 0;
        }
        .latex-js-output td, .latex-js-output th {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 0.5em;
        }
        
        /* Styles for LaTeX documents */
        .latex-document {
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .latex-document .title {
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            margin: 1em 0;
        }
        .latex-document .author {
            text-align: center;
            margin: 0.5em 0;
        }
        .latex-document .date {
            text-align: center;
            margin: 0.5em 0;
        }
        .latex-document .content {
            margin: 1em 0;
            line-height: 1.6;
        }
        
        /* Styles for lists */
        ol {
            margin: 1em 0;
            padding-left: 2em;
        }
        ol li {
            margin: 0.5em 0;
            color: white;
        }
        
        /* Styles for arrays */
        .tabular {
            border-collapse: collapse;
            margin: 1em 0;
            width: auto;
        }
        .tabular td {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 0.5em;
            color: white;
        }
        
        /* Styles for math formulas */
        .MathJax_Display {
            margin: 1em 0 !important;
        }
    </style>
</head>
<body>
    <div id="formula"></div>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                packages: ['base', 'ams', 'noerrors', 'noundefined'],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    console.log('MathJax is ready');
                    MathJax.startup.defaultReady();
                    window.webkit.messageHandlers.mathjaxReady.postMessage('ready');
                }
            },
            chtml: {
                scale: 1,
                minScale: .5,
                mtextInheritFont: true
            }
        };
        
        function renderLatexBlock(content, title) {
            console.log('Rendering block:', { content });
            return `
                <div class="latex-block">
                    <div class="latex-content">
                        ${content}
                    </div>
                </div>
            `;
        }
        
        async function processLatexDocument(content) {
            console.log('Processing LaTeX document:', content);
            try {
                let processedContent = content;
                
                processedContent = processedContent.replace(/\\begin{enumerate}([\s\S]*?)\\end{enumerate}/g, (match, items) => {
                    const listItems = items.split('\\item').filter(item => item.trim());
                    return '<ol>' +
                        listItems.map(item => `<li>${item.trim()}</li>`).join('') +
                        '</ol>';
                });
                
                processedContent = processedContent.replace(/\\begin{tabular}{([^}]*)}([\s\S]*?)\\end{tabular}/g, (match, format, content) => {
                    const rows = content.split('\\\\').map(row => row.trim());
                    const table = rows.map(row => {
                        const cells = row.split('&').map(cell => cell.trim().replace('\\hline', ''));
                        return '<tr>' + cells.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
                    }).join('');
                    return `<table class="tabular">${table}</table>`;
                });
                
                if (content.includes('\\documentclass')) {
                    console.log('Processing full document');
                    const title = content.match(/\\title{([^}]*)}/)?.[1] || '';
                    const author = content.match(/\\author{([^}]*)}/)?.[1] || '';
                    const date = content.match(/\\date{([^}]*)}/)?.[1] || '';
                    
                    const documentContent = content.match(/\\begin{document}([\\s\\S]*?)\\end{document}/)?.[1] || '';
                    
                    let html = '<div class="latex-document">';
                    if (title) html += `<h1 class="title">${title}</h1>`;
                    if (author) html += `<div class="author">${author}</div>`;
                    if (date) html += `<div class="date">${date}</div>`;
                    html += `<div class="content">${documentContent}</div>`;
                    html += '</div>';
                    
                    return renderLatexBlock(html, 'Document LaTeX');
                } else {
                    console.log('Processing as math formula');
                    if (content.trim().startsWith('\\[') && content.trim().endsWith('\\]')) {
                        return renderLatexBlock(content, 'Formule math√©matique');
                    } else {
                        return renderLatexBlock(processedContent, 'LaTeX');
                    }
                }
            } catch (e) {
                console.error('Erreur LaTeX:', e);
                return renderLatexBlock(`<pre>${content}</pre>`, 'LaTeX (Error)');
            }
        }
        
        window.processLatexContent = async function(text) {
            console.log('Processing content:', text);
            try {
                let html = '';
                let currentPos = 0;
                const codeBlockRegex = /```(latex)?\\n([\s\S]*?)```/g;
                let match;
                
                if (!text.includes('```')) {
                    console.log('Processing as direct formula');
                    html = await processLatexDocument(text);
                } else {
                    while ((match = codeBlockRegex.exec(text)) !== null) {
                        console.log('Found code block:', match);
                        if (match.index > currentPos) {
                            html += text.slice(currentPos, match.index);
                        }
                        
                        const isLatex = match[1] === 'latex';
                        const content = match[2].trim();
                        
                        if (isLatex) {
                            html += await processLatexDocument(content);
                        } else {
                            html += renderLatexBlock(`<pre>${content}</pre>`, 'Code');
                        }
                        
                        currentPos = match.index + match[0].length;
                    }
                    
                    if (currentPos < text.length) {
                        html += text.slice(currentPos);
                    }
                }
                
                console.log('Final HTML:', html);
                document.getElementById('formula').innerHTML = html;
                await MathJax.typesetPromise();
                console.log('MathJax typesetting complete');
                window.webkit.messageHandlers.contentProcessed.postMessage('done');
            } catch (e) {
                console.error('Erreur de traitement:', e);
                document.getElementById('formula').textContent = e.message;
                window.webkit.messageHandlers.contentProcessed.postMessage('error');
            }
        }
    </script>
</body>
</html>
